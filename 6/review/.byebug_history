quit
n
win
n
win
n
win
n
diagonals
n
c
quit
s
win_conditions.include?('WWW')
columns
n
c
n
v_win
n
columns
n
columns
quit
n
win_condition
rows[0].join
rows
n
c
quit
rows
n
rows
n
squares
n
win_condition
n
c
n
quit
  nil
  rows.each { |row| return row[0] if win_condition.include?(row.join) }
  BOARD_SIDE.times { rows << squares.shift(4).map { |v| board_vals[v] } }
  rows = []
  squares = board_vals.keys
  win_condition = [USER * BOARD_SIDE, CPU * BOARD_SIDE]
def horizontal_win(board_vals)
board_vals
n
ls
end
  nil
  rows.each { |row| return row[0] if win_condition.include?(row.join) }
  BOARD_SIDE.times { rows << squares.shift(4).map { |v| board_vals[v] } }
  rows = []
  squares = board_vals.keys
  win_condition = [USER * BOARD_SIDE, CPU * BOARD_SIDE]
def horizontal_win(board_vals)
n
next
quit
move
